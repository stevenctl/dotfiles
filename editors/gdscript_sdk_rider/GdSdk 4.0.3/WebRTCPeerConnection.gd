extends RefCounted
#brief Interface to a WebRTC peer connection.
#desc A WebRTC connection between the local computer and a remote peer. Provides an interface to connect, maintain and monitor the connection.
#desc Setting up a WebRTC connection between two peers from now on) may not seem a trivial task, but it can be broken down into 3 main steps:
#desc - The peer that wants to initiate the connection ([code]A[/code] from now on) creates an offer and send it to the other peer ([code]B[/code] from now on).
#desc - [code]B[/code] receives the offer, generate and answer, and sends it to [code]A[/code]).
#desc - [code]A[/code] and [code]B[/code] then generates and exchange ICE candidates with each other.
#desc After these steps, the connection should become connected. Keep on reading or look into the tutorial for more information.
class_name WebRTCPeerConnection

#desc Emitted when a new in-band channel is received, i.e. when the channel was created with [code]negotiated: false[/code] (default).
#desc The object will be an instance of [WebRTCDataChannel]. You must keep a reference of it or it will be closed automatically. See [method create_data_channel].
signal data_channel_received(channel: WebRTCDataChannel)
#desc Emitted when a new ICE candidate has been created. The three parameters are meant to be passed to the remote peer over the signaling server.
signal ice_candidate_created(media: String, index: int, name: String)
#desc Emitted after a successful call to [method create_offer] or [method set_remote_description] (when it generates an answer). The parameters are meant to be passed to [method set_local_description] on this object, and sent to the remote peer over the signaling server.
signal session_description_created(type: String, sdp: String)
#desc The connection is new, data channels and an offer can be created in this state.
#desc The peer is connecting, ICE is in progress, none of the transports has failed.
#desc The peer is connected, all ICE transports are connected.
#desc At least one ICE transport is disconnected.
#desc One or more of the ICE transports failed.
#desc The peer connection is closed (after calling [method close] for example).
#desc The peer connection was just created and hasn't done any networking yet.
#desc The ICE agent is in the process of gathering candidates for the connection.
#desc The ICE agent has finished gathering candidates. If something happens that requires collecting new candidates, such as a new interface being added or the addition of a new ICE server, the state will revert to gathering to gather those candidates.
#desc There is no ongoing exchange of offer and answer underway. This may mean that the [WebRTCPeerConnection] is new ([constant STATE_NEW]) or that negotiation is complete and a connection has been established ([constant STATE_CONNECTED]).
#desc The local peer has called [method set_local_description], passing in SDP representing an offer (usually created by calling [method create_offer]), and the offer has been applied successfully.
#desc The remote peer has created an offer and used the signaling server to deliver it to the local peer, which has set the offer as the remote description by calling [method set_remote_description].
#desc The offer sent by the remote peer has been applied and an answer has been created and applied by calling [method set_local_description]. This provisional answer describes the supported media formats and so forth, but may not have a complete set of ICE candidates included. Further candidates will be delivered separately later.
#desc A provisional answer has been received and successfully applied in response to an offer previously sent and established by calling [method set_local_description].
#desc The [WebRTCPeerConnection] has been closed.

#enum ConnectionState
enum {
    STATE_NEW = 0,
    STATE_CONNECTING = 1,
    STATE_CONNECTED = 2,
    STATE_DISCONNECTED = 3,
    STATE_FAILED = 4,
    STATE_CLOSED = 5,
}
#enum GatheringState
enum {
    GATHERING_STATE_NEW = 0,
    GATHERING_STATE_GATHERING = 1,
    GATHERING_STATE_COMPLETE = 2,
}
#enum SignalingState
enum {
    SIGNALING_STATE_STABLE = 0,
    SIGNALING_STATE_HAVE_LOCAL_OFFER = 1,
    SIGNALING_STATE_HAVE_REMOTE_OFFER = 2,
    SIGNALING_STATE_HAVE_LOCAL_PRANSWER = 3,
    SIGNALING_STATE_HAVE_REMOTE_PRANSWER = 4,
    SIGNALING_STATE_CLOSED = 5,
}


#desc Add an ice candidate generated by a remote peer (and received over the signaling server). See [signal ice_candidate_created].
func add_ice_candidate(media: String, index: int, name: String) -> int:
	pass;

#desc Close the peer connection and all data channels associated with it.
#desc [b]Note:[/b] You cannot reuse this object for a new connection unless you call [method initialize].
func close() -> void:
	pass;

#desc Returns a new [WebRTCDataChannel] (or [code]null[/code] on failure) with given [code]label[/code] and optionally configured via the [code]options[/code] dictionary. This method can only be called when the connection is in state [constant STATE_NEW].
#desc There are two ways to create a working data channel: either call [method create_data_channel] on only one of the peer and listen to [signal data_channel_received] on the other, or call [method create_data_channel] on both peers, with the same values, and the [code]negotiated[/code] option set to [code]true[/code].
#desc Valid [code]options[/code] are:
#desc [codeblock]
#desc {
#desc "negotiated": true, # When set to true (default off), means the channel is negotiated out of band. "id" must be set too. "data_channel_received" will not be called.
#desc "id": 1, # When "negotiated" is true this value must also be set to the same value on both peer.
#desc 
#desc # Only one of maxRetransmits and maxPacketLifeTime can be specified, not both. They make the channel unreliable (but also better at real time).
#desc "maxRetransmits": 1, # Specify the maximum number of attempt the peer will make to retransmits packets if they are not acknowledged.
#desc "maxPacketLifeTime": 100, # Specify the maximum amount of time before giving up retransmitions of unacknowledged packets (in milliseconds).
#desc "ordered": true, # When in unreliable mode (i.e. either "maxRetransmits" or "maxPacketLifetime" is set), "ordered" (true by default) specify if packet ordering is to be enforced.
#desc 
#desc "protocol": "my-custom-protocol", # A custom sub-protocol string for this channel.
#desc }
#desc [/codeblock]
#desc [b]Note:[/b] You must keep a reference to channels created this way, or it will be closed.
func create_data_channel(label: String, options: Dictionary = {}) -> WebRTCDataChannel:
	pass;

#desc Creates a new SDP offer to start a WebRTC connection with a remote peer. At least one [WebRTCDataChannel] must have been created before calling this method.
#desc If this functions returns [constant OK], [signal session_description_created] will be called when the session is ready to be sent.
func create_offer() -> int:
	pass;

#desc Returns the connection state. See [enum ConnectionState].
func get_connection_state() -> int:
	pass;

#desc Returns the ICE [enum GatheringState] of the connection. This lets you detect, for example, when collection of ICE candidates has finished.
func get_gathering_state() -> int:
	pass;

#desc Returns the [enum SignalingState] on the local end of the connection while connecting or reconnecting to another peer.
func get_signaling_state() -> int:
	pass;

#desc Re-initialize this peer connection, closing any previously active connection, and going back to state [constant STATE_NEW]. A dictionary of [code]options[/code] can be passed to configure the peer connection.
#desc Valid [code]options[/code] are:
#desc [codeblock]
#desc {
#desc "iceServers": [
#desc {
#desc "urls": [ "stun:stun.example.com:3478" ], # One or more STUN servers.
#desc },
#desc {
#desc "urls": [ "turn:turn.example.com:3478" ], # One or more TURN servers.
#desc "username": "a_username", # Optional username for the TURN server.
#desc "credential": "a_password", # Optional password for the TURN server.
#desc }
#desc ]
#desc }
#desc [/codeblock]
func initialize(configuration: Dictionary = {}) -> int:
	pass;

#desc Call this method frequently (e.g. in [method Node._process] or [method Node._physics_process]) to properly receive signals.
func poll() -> int:
	pass;

#desc Sets the [code]extension_class[/code] as the default [WebRTCPeerConnectionExtension] returned when creating a new [WebRTCPeerConnection].
static func set_default_extension(extension_class: StringName) -> void:
	pass;

#desc Sets the SDP description of the local peer. This should be called in response to [signal session_description_created].
#desc After calling this function the peer will start emitting [signal ice_candidate_created] (unless an [enum Error] different from [constant OK] is returned).
func set_local_description(type: String, sdp: String) -> int:
	pass;

#desc Sets the SDP description of the remote peer. This should be called with the values generated by a remote peer and received over the signaling server.
#desc If [code]type[/code] is [code]offer[/code] the peer will emit [signal session_description_created] with the appropriate answer.
#desc If [code]type[/code] is [code]answer[/code] the peer will start emitting [signal ice_candidate_created].
func set_remote_description(type: String, sdp: String) -> int:
	pass;


